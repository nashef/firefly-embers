{% extends "common/insert_signed.rho" %}

{%- block name -%} agentsTeams {%- endblock -%}

{%- block initialization -%}
{%- filter indent(8) -%}

new rl(`rho:registry:lookup`),
    revAddress(`rho:rev:address`),
    devNull(`rho:io:devNull`),
    abort(`rho:execution:abort`),
    deployData(`rho:deploy:data`),
    treeHashMapCh,
    agentsTeamsMapCh,
    agentsTeamsDeploysMapCh,
    tokensCh,
    listOpsCh,
    stackCh,
    visit,
    getLastDeployForAgentsTeam,
    notNil
in {
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |
    for(treeHashMap <<- treeHashMapCh) {
        treeHashMap!("init", 3, *agentsTeamsMapCh) |

        for(@map <- agentsTeamsMapCh) {
            agentsTeamsMapCh!(*treeHashMap, map)
        } |

        treeHashMap!("init", 3, *agentsTeamsDeploysMapCh) |

        for(@map <- agentsTeamsDeploysMapCh) {
            agentsTeamsDeploysMapCh!(*treeHashMap, map)
        }
    } |

    rl!(`rho:lang:listOps`, *listOpsCh) |
    for(@(_, listOps) <- listOpsCh) {
        listOpsCh!(listOps)
    } |

    rl!(`rho:lang:stack`, *stackCh) |
    for(@(_, stack) <- stackCh) {
        @stack!("init", *tokensCh) |
        stackCh!(stack)
    } |

    contract visit(@"agentsTeams", @address, f, notFound) = {
        for(treeHashMap, @map <<- agentsTeamsMapCh) {
            treeHashMap!("getOrElse", map, address, *f, *notFound)
        }
    } |

    contract visit(@"agentsTeamVersions", @address, @id, f, notFound) = {
        new foundCh in {
            visit!("agentsTeams", address, *foundCh, *notFound) |

            for(@(agentsTeams, _) <- foundCh; treeHashMap <<- treeHashMapCh) {
                treeHashMap!("getOrElse", agentsTeams, id, *f, *notFound)
            }
        }
    } |

    contract visit(@"agentsTeamVersion", @address, @id, @version, f, notFound) = {
        new foundCh in {
            visit!("agentsTeamVersions", address, id, *foundCh, *notFound) |

            for(@(agentsTeamVersions, _) <- foundCh; treeHashMap <<- treeHashMapCh) {
                treeHashMap!("getOrElse", agentsTeamVersions, version, *f, *notFound)
            }
        }
    } |

    contract getLastDeployForAgentsTeam(@address, @id, ret) = {
        for(treeHashMap, @map <<- agentsTeamsDeploysMapCh) {
            new valueCh, setLastDeployNil in {
                treeHashMap!("getOrElse", map, address, *valueCh, *setLastDeployNil) |

                for(@agentsTeamsDeploys <- valueCh) {
                    treeHashMap!("getOrElse", agentsTeamsDeploys, id, *ret, *setLastDeployNil)
                } |

                for(<- setLastDeployNil) {
                    ret!(Nil)
                }
            }
        }
    } |

    contract notNil(@v, ret) = {
        ret!(v != Nil)
    } |

    contract agentsTeams(@"create", @id, @version, @created_at, @name, @description, @shard, @logo, @graph) = {
        new deployDataCh, deployerAddressCh, valueCh, nilCh, errCh in {
            deployData!(*deployDataCh) |

            for(_, @deployerId, _ <- deployDataCh) {
                revAddress!("fromDeployerId", deployerId, *deployerAddressCh)
            } |

            for(@address <- deployerAddressCh) {
                visit!("agentsTeams", address, *valueCh, *nilCh) |

                for(<- nilCh; treeHashMap, @map <<- agentsTeamsMapCh; stack <<- stackCh) {
                    new agentsTeamsCh, agentsTeamsIndexCh in {
                        treeHashMap!("init", 3, *agentsTeamsCh) |
                        stack!("init", *agentsTeamsIndexCh) |

                        for(
                            @agentsTeams <- agentsTeamsCh &
                            @agentsTeamsIndex <- agentsTeamsIndexCh
                        ) {
                            treeHashMap!("set", map, address, (agentsTeams, agentsTeamsIndex), *devNull) |
                            valueCh!((agentsTeams, agentsTeamsIndex))
                        }
                    }
                }
            } |

            for(@(agentsTeams, agentsTeamsIndex) <- valueCh; treeHashMap <<- treeHashMapCh; stack <<- stackCh) {
                new insertAgentsTeamCh, agentsTeamVersionsCh, agentsTeamVersionsIndexCh in {
                    treeHashMap!("getOrElse", agentsTeams, id, *errCh, *insertAgentsTeamCh) |

                    for(<- insertAgentsTeamCh) {
                        stack!("push", agentsTeamsIndex, id, *devNull) |

                        treeHashMap!("init", 3, *agentsTeamVersionsCh) |
                        stack!("init", *agentsTeamVersionsIndexCh) |

                        for(
                            @agentsTeamVersions <- agentsTeamVersionsCh &
                            @agentsTeamVersionsIndex <- agentsTeamVersionsIndexCh
                        ) {
                            treeHashMap!("set", agentsTeams, id, (agentsTeamVersions, agentsTeamVersionsIndex), *devNull) |

                            treeHashMap!("set", agentsTeamVersions, version,
                                {
                                    "created_at": created_at,
                                    "last_deploy": Nil,
                                    "name": name,
                                    "description": description,
                                    "shard": shard,
                                    "logo": logo,
                                    "graph": graph,
                                }, *devNull) |

                            treeHashMap!("set", agentsTeamVersions, "latest",
                                {
                                    "version": version,
                                    "created_at": created_at,
                                    "last_deploy": Nil,
                                    "name": name,
                                    "description": description,
                                    "shard": shard,
                                    "logo": logo,
                                    "graph": graph,
                                }, *devNull) |

                            stack!("push", agentsTeamVersionsIndex, version, *devNull)
                        }
                    }
                }
            } |

            for(<- errCh) {
                abort!("in createAiAgentsTeam")
            }
        }
    } |

    contract agentsTeams(@"list", @address, ret) = {
        new valueCh, nilCh in {
            visit!("agentsTeams", address, *valueCh, *nilCh) |

            for(@(agentsTeams, agentsTeamsIndex) <- valueCh; treeHashMap <<- treeHashMapCh; listOps <<- listOpsCh; stack <<- stackCh) {
                new toAgentsTeamHeader, agentsTeamsListCh, aggregateCh in {
                    contract toAgentsTeamHeader(@id, ret) = {
                        new agentsTeamContextCh, agentsTeamLastVersionCh, lastDeployCh in {
                            treeHashMap!("get", agentsTeams, id, *agentsTeamContextCh) |

                            for(@(agentsTeamVersions, _) <- agentsTeamContextCh) {
                                treeHashMap!("get", agentsTeamVersions, "latest", *agentsTeamLastVersionCh) |
                                getLastDeployForAgentsTeam!(address, id, *lastDeployCh) |

                                for(@agentsTeamLastVersion <- agentsTeamLastVersionCh & @lastDeploy <- lastDeployCh) {
                                    match lastDeploy {
                                        Nil => ret!(agentsTeamLastVersion.delete("graph").union({"id": id}))
                                        _ => ret!(agentsTeamLastVersion.delete("graph").union({"id": id}).union(lastDeploy))
                                    }
                                }
                            } |

                            for(@Nil <- agentsTeamContextCh) {
                                ret!(Nil)
                            }
                        }
                    } |

                    stack!("toList", agentsTeamsIndex, *agentsTeamsListCh) |

                    for(@agentsTeamsList <- agentsTeamsListCh) {
                        listOps!("unorderedParMap", agentsTeamsList, *toAgentsTeamHeader, *aggregateCh) |
                        for(@aggregate <- aggregateCh) {
                            listOps!("filter", aggregate, *notNil, *ret)
                        }
                    }
                }
            } |

            for(<- nilCh) {
                ret!([])
            }
        }
    } |

    contract agentsTeams(@"listVersions", @address, @id, ret) = {
        new valueCh, nilCh, agentsTeamVersionsListCh, lastDeployCh, toAgentsTeamHeader in {
            visit!("agentsTeamVersions", address, id, *valueCh, *nilCh) |

            for(@(agentsTeamVersions, agentsTeamVersionsIndex) <- valueCh; treeHashMap <<- treeHashMapCh; listOps <<- listOpsCh; stack <<- stackCh) {
                getLastDeployForAgentsTeam!(address, id, *lastDeployCh) |

                contract toAgentsTeamHeader(@version, ret) = {
                    new versionCh in {
                        treeHashMap!("get", agentsTeamVersions, version, *versionCh) |

                        for(@agentsTeamVersion <- versionCh; @lastDeploy <<- lastDeployCh) {
                            match lastDeploy {
                                Nil => ret!(agentsTeamVersion.delete("graph").union({"id": id, "version": version}))
                                _ => ret!(agentsTeamVersion.delete("graph").union({"id": id, "version": version}).union(lastDeploy))
                            }
                        }
                    }
                } |

                stack!("toList", agentsTeamVersionsIndex, *agentsTeamVersionsListCh) |

                for(@agentsTeamVersionsList <- agentsTeamVersionsListCh) {
                    listOps!("parMap", agentsTeamVersionsList, *toAgentsTeamHeader, *ret)
                }
            } |

            for(<- nilCh) {
                ret!(Nil)
            }
        }
    } |

    contract agentsTeams(@"get", @address, @id, @version, ret) = {
        new valueCh, nilCh, lastDeployCh in {
            visit!("agentsTeamVersion", address, id, version, *valueCh, *nilCh) |
            getLastDeployForAgentsTeam!(address, id, *lastDeployCh) |

            for(@agentsTeamVersion <- valueCh & @lastDeploy <- lastDeployCh) {
                match lastDeploy {
                    Nil => ret!(agentsTeamVersion.union({"id": id, "version": version}))
                    _ => ret!(agentsTeamVersion.union({"id": id, "version": version}).union(lastDeploy))
                }
            } |

            for(<- nilCh) {
                ret!(Nil)
            }
        }
    } |

    contract agentsTeams(@"save", @id, @version, @created_at, @name, @description, @shard, @logo, @graph) = {
        new deployDataCh, deployerAddressCh, valueCh, errCh, insertAgentsTeamVersionCh in {
            deployData!(*deployDataCh) |

            for(_, @deployerId, _ <- deployDataCh) {
                revAddress!("fromDeployerId", deployerId, *deployerAddressCh)
            } |

            for(@address <- deployerAddressCh) {
                visit!("agentsTeamVersions", address, id, *valueCh, *errCh)
            } |

            for(@(agentsTeamVersions, agentsTeamVersionsIndex) <- valueCh; treeHashMap <<- treeHashMapCh; stack <<- stackCh) {
                treeHashMap!("getOrElse", agentsTeamVersions, version, *errCh, *insertAgentsTeamVersionCh) |

                for(<- insertAgentsTeamVersionCh) {
                    stack!("push", agentsTeamVersionsIndex, version, *devNull) |

                    treeHashMap!("set", agentsTeamVersions, version,
                        {
                            "created_at": created_at,
                            "last_deploy": Nil,
                            "name": name,
                            "description": description,
                            "shard": shard,
                            "logo": logo,
                            "graph": graph,
                        }, *devNull) |

                    treeHashMap!("set", agentsTeamVersions, "latest",
                        {
                            "version": version,
                            "created_at": created_at,
                            "last_deploy": Nil,
                            "name": name,
                            "description": description,
                            "shard": shard,
                            "logo": logo,
                            "graph": graph,
                        }, *devNull)
                }
            } |

            for(<- errCh) {
                abort!("in saveAiAgentsTeam")
            }
        }
    } |

    contract agentsTeams(@"delete", @id) = {
        new deployDataCh, deployerAddressCh, valueCh in {
            deployData!(*deployDataCh) |

            for(_, @deployerId, _ <- deployDataCh) {
                revAddress!("fromDeployerId", deployerId, *deployerAddressCh)
            } |

            for(@address <- deployerAddressCh) {
                visit!("agentsTeams", address, *valueCh, *devNull)
            } |

            for(@(agentsTeams, _) <- valueCh; treeHashMap <<- treeHashMapCh) {
                treeHashMap!("delete", agentsTeams, id, *devNull)
            }
        }
    } |

    contract agentsTeams(@"recordDeploy", @id, @uri, @last_deploy) = {
        new deployDataCh, deployerAddressCh, valueCh, nilCh in {
            deployData!(*deployDataCh) |

            for(_, @deployerId, _ <- deployDataCh) {
                revAddress!("fromDeployerId", deployerId, *deployerAddressCh)
            } |

            for(@address <- deployerAddressCh; treeHashMap, @map <<- agentsTeamsDeploysMapCh) {
                treeHashMap!("getOrElse", map, address, *valueCh, *nilCh) |

                for(<- nilCh) {
                    new agentsTeamsDeploysCh in {
                        treeHashMap!("init", 3, *agentsTeamsDeploysCh) |

                        for(@agentsTeamsDeploys <- agentsTeamsDeploysCh) {
                            treeHashMap!("set", map, address, agentsTeamsDeploys, *devNull) |
                            valueCh!(agentsTeamsDeploys)
                        }
                    }
                } |

                for(@agentsTeamsDeploys <- valueCh) {
                    treeHashMap!("set", agentsTeamsDeploys, id, {"uri": uri, "last_deploy": last_deploy}, *devNull)
                }
            }
        }
    } |

    contract agentsTeams(@"saveFireskyToken", @uri, @nonce, @ciphertext) = {
        for(@tokens <<- tokensCh; stack <<- stackCh) {
            stack!("push", tokens, {"nonce": nonce, "ciphertext": ciphertext}, *devNull)
        }
    } |

    contract agentsTeams(@"getFireskyTokens", ret) = {
        for(@tokens <<- tokensCh; stack <<- stackCh) {
            stack!("toList", tokens, *ret)
        }
    }
}

{%- endfilter -%}
{%- endblock -%}
