{% extends "common/insert_signed.rho" %}

{%- block name -%} wallets {%- endblock -%}

{%- block initialization -%}
{%- filter indent(8) -%}

new rl(`rho:registry:lookup`),
    treeHashMapCh,
    revVaultCh,
    eitherCh,
    stackCh,
    abort(`rho:execution:abort`),
    devNull(`rho:io:devNull`),
    deployData(`rho:deploy:data`),
    okOrAbort,
    doTransfer,
    getOrCreateHistoryEntry,
    updateTransferHistory,
    updateBoostHistory,
    getTransactionsHistory,
    getBalance
in {
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |
    for(treeHashMap <- treeHashMapCh) {
        treeHashMap!("init", 3, *treeHashMapCh) |

        for(@map <- treeHashMapCh) {
            treeHashMapCh!(*treeHashMap, map)
        }
    } |

    rl!(`rho:rchain:revVault`, *revVaultCh) |
    for(@(_, revVault) <- revVaultCh) {
        revVaultCh!(revVault)
    } |

    rl!(`rho:lang:either`, *eitherCh) |
    for(@(_, either) <- eitherCh) {
        eitherCh!(either)
    } |

    rl!(`rho:lang:stack`, *stackCh) |
    for(@(_, stack) <- stackCh) {
        stackCh!(stack)
    } |

    contract okOrAbort(eitherCh, f, @log) = {
        for(@either <- eitherCh) {
            match either {
                (true, v) => f!(v)
                (false, err) => abort!([log, err])
            }
        }
    } |

    contract doTransfer(@deployerId, @walletAddressFrom, @walletAddressTo, @amount, @ret) = {
        new vaultCh, vaultToCh, revVaultkeyCh, transferOp in {
            for(revVault <<- revVaultCh) {
                revVault!("findOrCreate", walletAddressFrom, *vaultCh) |
                revVault!("findOrCreate", walletAddressTo, *vaultToCh) |
                revVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |

                for(@key <- revVaultkeyCh; _ <- vaultToCh; either <<- eitherCh) {
                    for(vault, @return <- transferOp) {
                        vault!("transfer", walletAddressTo, amount, key, return)
                    } |

                    either!("flatMap <-", *vaultCh, *transferOp, ret)
                }
            }
        }
    } |

    contract getOrCreateHistoryEntry(@walletOwner, ret) = {
        new nilCh in {
            for(treeHashMap, @map <<- treeHashMapCh; stack <<- stackCh) {
                treeHashMap!("getOrElse", map, walletOwner, *ret, *nilCh) |

                for(<- nilCh) {
                    new transferHistoryCh, boostHistoryCh in {
                        stack!("init", *transferHistoryCh) |
                        stack!("init", *boostHistoryCh) |

                        for(@transferHistory <- transferHistoryCh & @boostHistory <- boostHistoryCh) {
                            treeHashMap!("set", map, walletOwner, (transferHistory, boostHistory), *devNull) |
                            ret!((transferHistory, boostHistory))
                        }
                    }
                }
            }
        }
    } |

    contract updateTransferHistory(@walletOwner, @id, @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new userHistoryCh in {
            getOrCreateHistoryEntry!(walletOwner, *userHistoryCh) |

            for(@(transferHistory, _) <- userHistoryCh; stack <<- stackCh) {
                stack!("push", transferHistory, {
                    "id": id,
                    "timestamp": timestamp,
                    "from": walletAddressFrom,
                    "to": walletAddressTo,
                    "amount": amount,
                    "description": description,
                }, *devNull)
            }
        }
    } |

    contract wallets(@"transfer", @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new deployDataCh, transferResultCh, updateHistory in {
            deployData!(*deployDataCh) |
            for(either <<- eitherCh; _, @deployerId, @deployId <- deployDataCh) {
                doTransfer!(deployerId, walletAddressFrom, walletAddressTo, amount, *transferResultCh) |
                okOrAbort!(*transferResultCh, *updateHistory, "transfer failed") |

                for(_ <- updateHistory) {
                    updateTransferHistory!(walletAddressFrom, deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description) |
                    updateTransferHistory!(walletAddressTo  , deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description)
                }
            }
        }
    } |

    contract updateBoostHistory(@walletOwner, @id, @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description, @post_author_did, @post_id) = {
        new userHistoryCh in {
            getOrCreateHistoryEntry!(walletOwner, *userHistoryCh) |

            for(@(_, boostHistory) <- userHistoryCh; stack <<- stackCh) {
                stack!("push", boostHistory, {
                    "id": id,
                    "timestamp": timestamp,
                    "from": walletAddressFrom,
                    "to": walletAddressTo,
                    "amount": amount,
                    "description": description,
                    "post_author_did": post_author_did,
                    "post_id": post_id,
                }, *devNull)
            }
        }
    } |

    contract wallets(@"boost", @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description, @post_author_did, @post_id) = {
        new deployDataCh, transferResultCh, updateHistory in {
            deployData!(*deployDataCh) |
            for(either <<- eitherCh; _, @deployerId, @deployId <- deployDataCh) {
                doTransfer!(deployerId, walletAddressFrom, walletAddressTo, amount, *transferResultCh) |
                okOrAbort!(*transferResultCh, *updateHistory, "boost failed") |

                for(_ <- updateHistory) {
                    updateBoostHistory!(walletAddressFrom, deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description, post_author_did, post_id) |
                    updateBoostHistory!(walletAddressTo  , deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description, post_author_did, post_id)
                }
            }
        }
    } |

    contract getTransactionsHistory(@walletAddress, ret) = {
        new valueCh, nilCh in {
            for(treeHashMap, @map <<- treeHashMapCh) {
                treeHashMap!("getOrElse", map, walletAddress, *valueCh, *nilCh)
            } |

            for(<- nilCh) {
                ret!({"transfers": [], "boosts": []})
            } |

            for(@(transferHistory, boostHistory) <- valueCh; stack <<- stackCh) {
                new transferHistoryListCh, boostHistoryListCh in {
                    stack!("toList", transferHistory, *transferHistoryListCh) |
                    stack!("toList", boostHistory, *boostHistoryListCh) |

                    for(@transfers <- transferHistoryListCh & @boosts <- boostHistoryListCh) {
                        ret!({"transfers": transfers, "boosts": boosts})
                    }
                }
            }
        }
    } |

    contract getBalance(@walletAddress, ret) = {
        new vaultCh, balanceOp in {
            for(revVault <<- revVaultCh; either <<- eitherCh) {
                revVault!("findOrCreate", walletAddress, *vaultCh) |

                for(vault, return <- balanceOp) {
                    vault!("balance", *return)
                } |

                either!("map <-", *vaultCh, *balanceOp, *ret)
            }
        }
    } |

    contract wallets(@"getBalanceAndHistory", @walletAddress, ret) = {
        new balanceCh, historyCh, mapOp in {
            for(either <<- eitherCh) {
                getBalance!(walletAddress, *balanceCh) |
                getTransactionsHistory!(walletAddress, *historyCh) |

                either!("map <-", *balanceCh, *mapOp, *ret) |

                for(@balance, return <- mapOp & @history <- historyCh) {
                    return!({"balance": balance}.union(history))
                }
            }
        }
    }
}

{%- endfilter -%}
{%- endblock -%}
